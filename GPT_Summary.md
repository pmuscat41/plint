Functions in plint for Patent Claim Antecedent Basis Checking
Parsing Patent Claims Text
Main Parsing Routine: In plint.py, the core logic for reading and parsing the claims is in the main script (executed when the tool runs). Plint reads the patent claims from a text file (or a JSON config specifying the file) and parses them sequentially. It verifies basic formatting of each claim, such as ensuring each claim line begins with an integer followed by a period (e.g. "1.")
github.com
, that claim numbers are in order (no gaps or repeats)
github.com
, and that each claim ends with a period
github.com
. This parsing step uses only Python standard libraries (file I/O, string methods, possibly the re module for patterns). There isn’t a single dedicated parse_claims() function; instead, the script’s main block handles file reading and parsing inline. However, this parsing routine effectively performs the following:
Reading Input: If a JSON configuration file is provided (as shown in the README), plint loads it using Python’s json module (standard library) and retrieves the path to the claims text file. Otherwise, the claims text file path can be given directly as an argument. The code uses standard file I/O (open) to read the entire claims file.
Splitting and Grouping Lines: Plint treats each numbered claim as a unit. It likely accumulates lines until it encounters the next claim number. For each claim, it identifies the claim number and the claim text. For example, it will detect “1.” as the start of claim 1, then gather all subsequent lines (including indented subparagraphs) until claim 2 is encountered. The claim number is parsed to an integer (to check ordering) and the period after the number is confirmed
github.com
.
Basic Validations: The parser ensures no formatting issues: e.g., if a claim doesn’t start with an integer or if the numbering is out-of-sequence, it triggers a warning via the warn() function (see below). These format checks are “hard-coded” in the script (not in a separate function) as simple if conditions with calls to warn on failure. For example, if a claim line did not end in a period, assert_warn(...) is used to issue a warning
github.com
.
Output of Parsed Structure: The parsing routine stores claims in an internal list or dictionary (e.g., claims_list[claim_number] = claim_text). This structured representation is then used for subsequent analysis (antecedent checking, etc.). The parsing uses only built-in Python capabilities (no external libraries).
Function usage: While there is no dedicated parsing function, this main routine can be wrapped in a function for integration. For example, one could refactor it into a load_claims(file_path) -> List[str] function that returns a list of claim texts in order, after performing the above validations. In the current plint code, these steps are done inline in the __main__ section, but they rely only on standard Python (file I/O, json, and re for patterns), so they can be extracted and reused in a Dify agent easily.
Identification of Introduced and Referenced Terms
A key part of plint’s antecedent basis check is identifying introduced claim elements vs. subsequently referenced elements. Plint recognizes that words like “a”, “an”, “at least one”, or “one or more” signify a new element’s first introduction, whereas “the” or “said” signal references to an element introduced earlier
github.com
. In practice, plint uses a mark-up system: it marks new elements with curly braces {…} and previously introduced elements with square brackets […] in the claim text. This marking is done via regex finds and text replacements in the code (using the standard re module).
Automatic Marking: By default (unless the user enables manual marking via a flag), plint automatically scans each claim text for new and old elements. The code finds all substrings enclosed by braces { } – these represent newly introduced elements. For example, after reading the claim “A widget…”, plint internally interprets it as A {widget}. In code, this is done with re.finditer(r"\{.*?\}", claim_text) to find all occurrences of {…}
github.com
. Each found new element string (with braces stripped) is added to a set of introduced terms for that claim. Similarly, the script finds previously introduced elements by searching for text in square brackets [...] (using a similar re.finditer on the \[.*?\] pattern). These represent occurrences of “the X” or “said X” that refer to an earlier introduced X.
Maintaining State: Plint keeps track of introduced elements in each claim and perhaps propagates them to dependent claims. For an independent claim, the introduced-elements set starts empty and accumulates as new elements are found. For a dependent claim, plint likely initializes the introduced-elements set with all elements introduced in the ancestor claims it depends on (so it knows what is already available). Then it adds any new ones introduced in the dependent claim itself. This way, when it encounters a referenced element in brackets, it can check both the current claim’s introduced set and those inherited from parent claims
github.com
.
Functions/Code Involved: The identification is handled by inline code using Python’s regex and string functions, not a separate named function. For example, after identifying a new element, the code performs a replacement to ensure proper bracketing. In one snippet, plint replaces occurrences of an already-marked old element to adjust brackets: claim_text = claim_text.replace('['+new_element, '[~'+new_element+']')
github.com
. This indicates that if an element that was just introduced (new_element) is found with a [ (as if it were referenced before introduction), the code inserts a ~ (a marker to ignore insertion of an extra bracket) and ensures it’s closed with ]. This is essentially a cleanup to avoid duplicate brackets for elements that were manually marked as old. All these operations use Python’s built-in re and string handling – no external libraries.
Output/Usage: The result of this phase is a “marked-up” version of the claim (often written to a .marked file for debugging) where each claim element is clearly annotated as new or old. For integration into another system, the logic of this step can be wrapped into a function like mark_claim_elements(claim_text, known_elements) -> (marked_text, new_elements_set) – where known_elements are those introduced in previous related claims. In plint, however, this is done inline. The key takeaway is that regex-based functions (like Python’s re.finditer) and simple string manipulations are at the core of identifying introduced vs. referenced terms. These are all standard library operations.
Detection of Missing Antecedents
Once the claims are marked and the sets of introduced elements are known, plint checks for antecedent basis issues:
Missing Antecedent: If a referenced term (e.g., something in square brackets, meaning it’s preceded by “the” or “said” in the claim text) does not correspond to any term in the introduced-elements set (from the current claim or its dependencies), that indicates a missing antecedent. Plint will generate a warning for such cases. The code likely does this by iterating through each old element found (from the bracketed terms) and checking if it exists in the introduced set. If not, it calls the warn() function with a message like “Antecedent basis not found for [element] in claim X”. The logic for this check is implemented in plain Python: a membership test in a set or list. There isn’t a separate function just for “find_missing_antecedents”; instead, it’s part of the main loop analyzing each claim. For example, conceptually:
for old_element in old_elements:
    assert_warn(old_element in introduced_elements,
                f"No antecedent basis for '{old_element}' in claim {claim_no}")
Here assert_warn(condition, message) triggers a warning if condition is False. This matches the intended behavior – if an old element isn’t introduced earlier, raise a warning.
Duplicate Introduction: Similarly, plint checks if the same element is introduced more than once in a claim. If the code finds a new element in braces that is already in the introduced set, it will call warn() to flag a duplicate introduction
github.com
. The script likely does this check during the loop that processes new_elements. For each new element found via {...}, it does something like:
if new_element_name in introduced_elements:
    warn(f"Element '{new_element_name}' introduced more than once in claim {claim_no}")
else:
    introduced_elements.add(new_element_name)
The README confirms this behavior: “If a specific claim element is introduced more than once, a warning will be printed”
github.com
.
Dependent Claim References: Plint also ensures that if a claim is dependent, any element referenced in the dependent claim can be introduced in a parent claim. It uses the introduced-elements sets of ancestor claims for this. If a dependency is broken (e.g., claim 5 refers to an element introduced in claim 1, but the dependency chain of claim 5 doesn’t include claim 1), that’s effectively a missing antecedent too, and would be warned. The code likely already accounts for this by building the known elements from actual parent claims only.
Functions Involved: The detection itself is done via the assert_warn and warn utility functions (discussed below). The logic resides in the main script rather than a distinct function. However, conceptually this could be a function like check_antecedents(introduced_set, referenced_set, claim_no) -> list of issues. Internally, plint just uses loops and calls to warn. All operations here are standard Python (set membership, etc.). Output/Formatting: When a missing antecedent or duplicate introduction is found, plint uses warn() to output a formatted warning message. For example, a message might be: “Claim 5: ‘the widget’ has no antecedent basis” (the exact wording depends on plint’s internal messages). These messages are collected and printed to stderr or an output file. Notably, all steps in missing antecedent detection rely only on standard libraries (no external dependencies). The regex finds from the identification phase provide the data, and simple Python conditions generate the warnings.
Utility Functions for Warnings and Output
Plint defines a few helper functions that are crucial for reporting issues and matching patterns. All of these are implemented using standard Python libraries:
eprint(*args, **kwargs) – Purpose: A helper to print messages either to stderr or to an output file if one is specified. In plint’s design, if the user requested an output file (via the outfile flag in JSON config), eprint will append the message to that file; otherwise, it writes to standard error. This prevents mixing with normal stdout and allows capturing all warnings.
Parameters: It accepts any arguments like the built-in print(). There are no special required types beyond strings (it passes *args to print).
Return: None. It performs I/O.
Implementation: It checks a global flag use_outfile. If false, it simply calls print(*args, file=sys.stderr, **kwargs) to print the message to stderr. If true, it opens the specified outfile and writes the message there
github.com
. This uses only Python’s sys module and built-in file handling (standard library).
Role in Antecedent Check: All warning messages ultimately funnel through eprint (via warn). When integrating into a Dify agent, one might override or wrap eprint to collect messages in-memory instead of printing.
warn(message, dav_keyword=None) – Purpose: This function logs a warning message (for any issue found) and increments a global warning count. It is a generic warning emitter used for all types of issues, including antecedent basis problems. The optional dav_keyword (likely “definiteness analysis keyword”) is used to track certain keywords in warnings (perhaps for filtering or stats).
Parameters: message is a string containing the warning text. dav_keyword is an optional string that, if provided, is added to a global set dav_keywords. Both parameters are simple Python types (str).
Return: None (it produces output and updates counters).
Implementation: Inside, warn uses the eprint function to actually output the message
github.com
. It maintains number_of_warnings as a global counter, incrementing it each time a warning is printed. It also respects filtering: plint allows users to filter out certain warnings (via a --filter regex list). The code checks a global rule_filters list – if it’s set, warn will skip printing any message that matches one of the filter regex patterns. This is done with Python’s re.search on each filter pattern. If none of the filters match the message (or if no filter is set), the message is printed and the count incremented
github.com
. If a dav_keyword is provided, it’s added to the dav_keywords global set (for later reference or output summary). All of this uses standard Python libraries (sys, re).
Role: Every antecedent issue (missing antecedent or duplicate introduction) triggers a call to warn. For example, warn("No antecedent basis for 'X' in claim 5") would be invoked when appropriate. In a Dify agent integration, one could replace warn with a version that, instead of printing, collects warnings in a list or JSON structure to return to the user.
assert_warn(bool_input, message, dav_keyword=None) – Purpose: A convenience function that simplifies conditional warnings. It checks a boolean condition and calls warn(message, dav_keyword) if the condition is false
github.com
. Essentially, “assert with warning instead of exception.”
Parameters: bool_input is a boolean expression (or a value interpretable as boolean) – for example, a check like old_element in introduced_set. message and dav_keyword are the same as in warn.
Return: None. If bool_input is True, nothing happens; if False, it invokes warn.
Implementation: One line: if not bool_input: warn(message, dav_keyword=dav_keyword)
github.com
. This uses the warn function internally.
Role: In plint’s code, many checks use assert_warn. For instance, after parsing claims, the code might do assert_warn(claim_text.endswith('.'), "Claim X does not end with a period") to issue a warning if a claim is not properly terminated. In antecedent basis logic, it could be used as shown above to warn if an element has no antecedent (assert_warn(element_in_set, "No antecedent for ...")). This function uses only standard Python logic and the custom warn. For integration, one can utilize assert_warn similarly, or simply replicate its logic with an if in custom code.
re_matches(regex, text) – Purpose: A helper for regex pattern matching (likely used to scan the claims against the list of known problematic phrases in claims.csv). It checks if a regex pattern occurs in a given text (case-insensitive), and if so, returns the match.
Parameters: regex (string, a regular expression) and text (the string to search in).
Return: A tuple (bool, str_or_None). It returns (False, None) if no match is found
github.com
. If a match is found, it returns (True, match_str) where match_str is the actual substring that matched. Internally it likely uses re.search twice (or re.search and then accesses group(0)). The code snippet suggests: if no match, return False; else find the match and return True with the matched text
github.com
.
Role: This function is mostly used for general warnings (the claims.csv rules). For example, plint’s warnings file might have a regex for “\belement\b” to warn about means-plus-function language; re_matches would detect it in the claim text and then warn with the corresponding message. It’s not specific to antecedent basis, but it’s part of the toolkit of functions. It uses only the built-in re module (no external regex library). In a Dify agent, re_matches can be used to apply custom regex rules if needed, or one can rely on Python’s re directly.
All the above functions use only standard Python libraries. There are no third-party dependencies in plint. For instance, warn and assert_warn use Python’s re and sys modules (both standard), and file I/O for eprint is via built-in functions
github.com
github.com
. This makes it easier to integrate into other Python-based tools, as you don’t need any unusual environment setup.
Integrating plint’s Functions into a Dify Agent
To use these capabilities in a Dify agent, one approach is to wrap plint’s logic in a function that takes the claims text as input and returns structured results (like a list of comments or warnings). Since plint was designed as a command-line tool, its main script prints output rather than returning values. Integration will likely involve redirecting or capturing those outputs. Some guidance:
Use main() or Emulate It: Plint doesn’t explicitly define a main() function; instead, its functionality runs under if __name__ == "__main__". You can mimic this by importing plint.py as a module in your agent (if possible) and then calling its functionality. For example, you could call an entry function (if you add one) or directly invoke pieces of the code. A simpler integration is to call plint via a subprocess, but that’s less efficient for an agent. Ideally, refactor plint’s script into callable functions (e.g., a function that accepts the text of claims and returns a list of warning messages).
Wrap the Warning Functions: Modify or wrap warn/eprint to collect output. For instance, you could override eprint to append messages to a list instead of printing. Since warn() calls eprint, this would capture all warnings. After running the antecedent check, that list can be returned by your agent. This way, the agent can supply the patent claims text to plint’s logic and get back the warnings as a Python list or JSON. This customization is straightforward because warn and eprint are pure Python and self-contained.
Feeding Input: The agent can take the user-pasted claims text and write it to a temporary file, then point plint to that file path (simulating the normal usage). However, a more direct approach is to bypass file I/O by injecting the text into the logic. You could split the text by lines and feed it to the parsing routine in-memory. All of plint’s parsing and regex checks can operate on in-memory strings, so file writing isn’t strictly necessary except that plint’s code as written expects a filename. Adapting it to take a string input is a matter of a few lines (replacing the file reading part with the given string).
Using the Functions Directly: Many of the identified functions (warn, assert_warn, etc.) can be used as-is in the agent code. For example, you might use assert_warn(claim_no in dependencies, "Dependent claim refers to non-existent claim") within your own logic. Since they are small and use no external state except the globals they manage, you could even copy their implementations into your agent if not importing the whole script. Just be mindful that warn in plint relies on some globals (number_of_warnings, rule_filters, etc.), which you would either replicate or simplify in your integration.
Output Structure: To meet the needs of a Dify agent (which likely expects a structured response, not just plain text), you should format the results. For instance, you could create a list of dictionaries like [{ "claim": 5, "issue": "no antecedent for 'widget'"}, …] or simply a list of strings. Plint’s own output is line-based text, but since you have programmatic access to the messages via the above functions, you can structure them arbitrarily before returning.
In summary, all necessary pieces of plint are accessible via simple Python functions or logic. The parsing and antecedent checks can be integrated by replicating the main script’s flow in a function, using the utility functions (warn, etc.) to detect and record issues. Since plint is open-source and uses standard libraries, a Dify agent can incorporate its logic without legal or technical obstacles. The key steps are to capture plint’s warnings (by overriding output functions) and to call the antecedent-basis analysis on the provided text. By doing so, the agent can return a comprehensive list of antecedent basis issues for the user’s patent claims, just like plint would report in its CLI output.
